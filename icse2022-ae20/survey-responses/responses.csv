ID,1.10 Do you find Rust's lifetime rules confusing when programming in Rust?,1.11 Do you find Rust's ownership rules confusing when programming in Rust?,"1.12 Do you understand the error messages provided by the Rust compiler, when your code violates lifetime rules?","1.13 Do you understand the error messages provided by the Rust compiler, when your code violates ownership rules?","1.14 Besides lifetime and ownership, please write down other language features of Rust that confuse you when you program with Rust.",PA Answer,PB Answer,Which PC?,PC.Q1 (a. Please mark the statement or the program tokens that cause the Rust compiler to reject the program.),PC.Q1 rating,"PC.Q2 (b. Please rate how easy or how difficult it is to figure out the error of the above program on a scale from 1 to 10. ``1'' means ``very easy'', and ``10'' means ``very difficult''.)",PC.Q3 (c. Which Rust safety rule is violated in the above program? ``[X]'' indicates a variable/type name in the program. Only one of the following options is correct.),PC.Q3 rating,"PC.Q4 (d. Given the above error messages, please rate how easy or how difficult it is to figure out the error of the above program on a scale from 1 to 10.)",PC.Q5 (e. Please rate the helpfulness of the above error messages to your understanding of the error on a scale from 1 to 10.),"PC.Q6 (f. In your own words, please explain the above compiler error.)",PC.Q6 rating,Which PD?,PD.Q1 (a. Please mark the statement or the program tokens that cause the Rust compiler to reject the program.),PD.Q1 rating,"PD.Q2 (b. Please rate how easy or how difficult it is to figure out the error of the above program on a scale from 1 to 10. ``1'' means ``very easy'', and ``10'' means ``very difficult''.)",PD.Q3 (c. Which Rust safety rule is violated in the above program? ``[X]'' indicates a variable/type name in the program. Only one of the following options is correct.),PD.Q3 rating,"PD.Q4 (d. Given the above error messages, please rate how easy or how difficult it is to figure out the error of the above program on a scale from 1 to 10.)",PD.Q5 (e. Please rate the helpfulness of the above error messages to your understanding of the error on a scale from 1 to 10.),"PD.Q6 (f. In your own words, please explain the above compiler error.)",PD.Q6 rating
1,Sometimes,Sometimes,Most of the time,Sometimes,nothing else really confuses me much with the language. It's very well put together,No,Yes,C1,"128: out1.a[1],136: out2.a.1",0.5,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,You can't borrow the same structure more than once using different types of mutability. This violates the safety rules because you can have a mutable pointer and a immutable pointer to the same data type. Rust is highlighting this code because you are already doing a mutable borrow of the datastructure attribute in the first argument so you can reference that same structure in the next argument as non mutable,5.8,D3,"95: &'a,96: Foo,108: bar.x",0,6,cannot move out of [X] which is behind a mutable reference,0,2,4,You can't borrow a mutable reference to the same location of memory twice because it may have changed location after the first reference is taken.,4.2
2,Most of the time,Sometimes,Sometimes,Most of the time,Asyncronous rust features~$br$~,No,Yes,C2,119: mut,0,5,cannot borrow [X] as immutable because it is also borrowed as mutable,0,4,4,-> 'test's first parameter takes an instance of 'Inner'~$br$~-> second parameter takes a mutable reference~$br$~-> field a from out1 seems to be moved as a whole and not its value at index 1~$br$~-> if first parameter's instance is identical with the second one -> borrow checker error occurs because test can't take a mutable ref to a moved value~$br$~~$br$~,4.2,D1_e,118: let,0,5,the trait `Copy` may not be implemented for this type,0,7,8,Method f1 takes a mutable reference of self for lifetime 'b (until bar2 gets out of scope). As f1 gets called a second time it violates Rust's single mutable reference rule because the first mutable reference is garanteed to live as long as Bar2's lifetime.,10
3,Most of the time,Sometimes,Sometimes,Most of the time,Readability compared to Python.~$br$~Implementing Rust to embedded specially controllers which not supported by LLVM.,No,Yes,C1_e,"127: &,128: out1.a[1]",1,6,Prefer not to answer,0,7,8,Little confused need more time to review,0,D3,"134: &mut,135: bar2);",1,7,cannot borrow [X] as mutable more than once at a time,1,3,8,Mutable borrow can't done more than one time.,5.8
4,Never,Never,Most of the time,Always,sync within async and async within sync or the mix of it since you can't spawn an executor within an executor,No,Yes,C2,"24: a:,25: [Inner;,26: 2],117: out1.a[1],,120: out1.a[0].in_a",0.25,6,cannot borrow [X] as immutable because it is also borrowed as mutable,0,2,9,The trait does not implement Copy and it is using the inner value from an array which requires moving the value out of the array.,7.6,D1_e,"37: mut,116: bar2.f1();,121: bar2.f1();",1,8,cannot borrow [X] as mutable more than once at a time,1,3,7,"bar2 was borrowed mutably twice which violates the ownership rule, not quite sure about the lifetime part but it is used to show the lifetime of borrowed bar2.",7.6
5,Most of the time,Sometimes,Most of the time,Most of the time,async rust,No,Yes,C2,119: mut,0,3,cannot borrow [X] as immutable because it is also borrowed as mutable,0,7,3,I thought another mistake but this is too difficult for me,0,D3,134: &mut,1,7,Prefer not to answer,0,7,3,I know it is connected to lifetime but can not explain it :(,3
6,Never,Never,Always,Most of the time,None,No,Yes,C1,99: Outer2,0,10,cannot return value referencing local variable [X],0,10,10,The error is difficult to identify since I am not a pro.  I believe maybe java  could get the work done with less complications,0,D1_e,106: bar2.f2(,0,10,cannot use [X] because it was mutably borrowed,0,10,10,"I was not able to identify the error, It is a difficult one because you cannot borrow `bar2` as mutable more than once at a time.",5.8
7,Sometimes,Sometimes,Most of the time,Most of the time,macro~$br$~unsfae,No,Yes,C3,"105: &out1.a[1];,110: &out2.a.1;",0.5,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Something has been mutably borrowed, and later an immutable borrow of it occurs, then the mutable borrow is used again. This means the mutable borrow needs to live after the immutable borrow. This violates rust's safety rules.~$br$~~$br$~The compiler is helpfully highlighting all the precise points that are relevant to the error.",5.8,D2,"35: f1(,53: f2,120: bar2.f1();",0.5,8,the parameter type [X] may not live long enough,0,1,10,"calling f1() takes self, which essentially consumes bar2~$br$~so bar2 itself becomes invalid and can't be used any more.~$br$~~$br$~The compiler is explaining that bar2 has already been consumed and thus cannot be used again. And since the type isn't copy, it can't be trivially duplicated.",10
8,Never,Never,Most of the time,Always,can't think of any at the moment,No,Yes,C3,"94: out1.a[0].in_a;,105: &out1.a[1];,112: *r1,123: r2);",1,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,1,"when out1.a[<int>] is borrowed as either immutable or mutable, the rust language borrows all of out1.a since partial borrowing doesn't work with arrays. Therefore, the compiler complains that out1.a is borrowed both immutably and mutably since we created a mutable borrow on line 24 that is still a live variable due to the later use on line 28 when we try to borrow immutably on line 26.",10,D1_e,"93: bar2,116: bar2.f1();,121: bar2.f1();",0.6666666667,4,cannot use [X] because it was mutably borrowed,0,6,6,"since we marked self with lifetime 'b in the definition of f1 (this should probably be changed), this forces the lifetime of 'b to be the same as bar2's lifetime, making bar2 only be able to be mutably borrowed once with bar2's lifetime. we tried to mutably borrow bar2 twice, causing the error.",10
9,Sometimes,Sometimes,Most of the time,Most of the time,"When I program with Rust, I'd like to be able to write less verbosely. One of the things I feel is that writing Rust Code can sometimes get maddeningly long, which forces different formatting. I think, however, this is the syntax of the language, and since this isn't a scripting language, it's something I'm willing to live with.",Yes,No,C3,"103: r2,108: r4",0.5,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,7,"In Rust, we can't have a mutable reference and an immutable reference to the same object. So, in this code, we can't compile because there are both. to fix this, we should pick which type of reference we want.",5.8,D2,"118: z,119: =,120: bar2.f1();",1,7,lifetime of reference outlives lifetime of borrowed content,0,2,9,"Since Bar2 doesn't implement Copy at assignments, the value is moved to bar2. This means that the first call to f1 takes ownership of the value, which makes it impossible to run the second call. If Bar2 implemented the Copy trait, then this problem wouldn't happen, since it makes sense that the extensive copies can be acted on differently.",10
10,Most of the time,Never,Sometimes,Always,Lack of specification of what can be done in unsafe code safely,No,Yes,C3,105: &out1.a[1];,1,4,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,10,"The array 'a' of 'out2' has been borrowed mutably in line 24 and used in line 28, and so its lifetime is within this duration. When it is borrowed mutably (exclusive access), an attempt to borrow 'a' of 'out2' immutably happens at line 26, violating exclusive access given to 'r1'.",7.6,D2,120: bar2.f1();,1,2,use of moved value: [X],1,1,10,"Data structure 'Bar2' is not Copy. Ownership of instance 'bar2' is moved into its method 'f1' during the first call (instead of copied) into 'self' and subsequently dropped when 'f1' exits. The second attempt to use 'f1' fails because 'bar2' no longer have ownership of the original object, and cannot be moved into 'self'.",10
11,Never,Never,Most of the time,Always,"Macros, mostly because I haven't invested the time to learn them.",No,Yes,C1_e,128: out1.a[1],1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,9,"The rust compiler considers the entire array to be borrowed even when only specific elements are borrowed. As the borrow of the zeroth element is mutable, the entire array is considered to be exclusively borrowed. The immutable borrow to the first element then fails.~$br$~~$br$~The second call is accepted as the fields are determined to be disjoint, and can be borrowed concurrently.",10,D3,"56: &Bar2,",0,7,wrong number of type arguments,0,1,9,"Only a single mutable borrow at a time is allowed. bar2 is borrowed mutably by the first call to the closure f3, then again by the second call to f3.~$br$~~$br$~The rust compiler cannot guarantee the first mutable borrow ends before the second mutable borrow, so it fails to compile.",5.8
12,Sometimes,Never,Most of the time,Always,Variance and implied bounds,No,Yes,C3,123: r2);,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,6,6,"When indexing an array (e.g. 'out1.a[0]'), the entire array is borrowed, not just the element being indexed. In general, it is impossible to determine at compile time if two array indices are the same, so the compiler conservatively causes '&mut out1.a[0]' and '&out1.a[1]' to cause borrows of the entire array 'out1.a'.~$br$~~$br$~From this point on, this is a standard borrow-checker error - a mutable borrow is obtained, an immtuable borrow to same location is obtian, and then the original mutable borrow is used. The usage of the immutable borrow 'invalidates' the mutable borrow, causing an error when it is used again.",10,D3,"134: &mut,135: bar2);",1,8,cannot borrow [X] as mutable more than once at a time,1,10,2,"This errors occurs due to the lifetime bounds in the function pointer 'f3'. The lifetime 'a in `&'a mut Bar2<'a>` in two places - the outer mutable reference, and the generic lifetime argument to 'Bar'. This requires that the mutable borrow of `Bar2 live as long as the reference stored by 'Bar'.~$br$~~$br$~Since the lifetime of the 'x' field in 'bar2' is tied to the reference to the local variable 'foo', it lives longer than just the call to 'f3'. Since the mutable reference to Bar2 is required to have the same lifetie as the reference to 'foo', the mutable reference remains active even after the call to 'f3' finishes. This results in a lifetime error if 'bar2' is later used again.",10
13,Most of the time,Never,Most of the time,Always,None that I can think of.,No,Yes,C3,"105: &out1.a[1];,110: &out2.a.1;",0.5,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Rust doesn't allow you to borrow any reference as a mutable and immutable simultaneously in the same scope. This prevents any shared read guarantee violations promised to the immutable borrow. However, this instance of code might confuse some readers into believing that just because the immutable and mutable borrows occur in different indices of out1 and out2, that this code should've compiled, because we know there is no mutation of any immutable value. But rust, doesn't see it that way, it only checks if out1 and out2, as a whole, have a &mut or & borrow, resulting in this error.",5.8,D2,120: bar2.f1();,1,5,use of moved value: [X],1,1,10,"fn f1(self) -> i32 {} is the source of the error. A method that takes 'self' is a method that takes the instance of the struct by value, hence causing a move. Had the method been a &self, this error could've been avoided.~$br$~",6
14,Never,Never,Most of the time,Most of the time,mutability,No,Yes,C3,"102: let,103: r2,104: =,105: &out1.a[1];",1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,9,9,"When a element of an array be borrowed, the total array will be counted.",8.4,D3,41: mut,0,7,Prefer not to answer,0,8,8,"At the first call `let _r = f3(&mut bar2);`, the compiler only known the `_r` should be released, but can not judge whether the `&mut bar2` could be released.",3
15,Sometimes,Never,Most of the time,Always,There are no significant language features in Rust that confuse me on a regular basis,No,Yes,C2,"117: out1.a[1],",1,4,"cannot move out of  [X], a non-copy [X]",1,2,9,"You can't move one item out of an array, only the entire array: I can't move out of element 1 while also borrowing element 0.~$br$~~$br$~By contrast, I can move one item out of a tuple. Element 0 and element 1 in the tuple are tracked independently by the compiler.",8.4,D1_e,40: &'b,0,9,lifetime of reference outlives lifetime of borrowed content,0,2,6,"The lifetime of the value returned on line 30 is bound to the lifetime 'b, which matches the scope of the foo variable, ie the entire function f4. The compiler cannot infer a shorter lifetime for the (temporary) return value on line 30, because lifetimes involved in mutable references are not covariant. The compiler's ~$dq$~note~$dq$~ hints at this, but does not precisely spell out the problem, or suggest a fix.~$br$~~$br$~Note that introducing a shorter covariant lifetime to function f1 would allow this to compile: fn f1(&'a mut self) -> &'a Foo",7.6
16,Sometimes,Never,Most of the time,Always,"- A couple of the more complex standard library types such as Cow<_, B> and Atomics~$br$~- async and Futures",No,Yes,C2,"120: out1.a[0].in_a,127: out2.a.0.in_a",0,6,use of moved value: [X],0,8,7,"I do not understand why this is the error shown. I expected that it would complain about the mutable borrows because out1 and out2 had already been moved, as inner does not implement Copy (my understanding is that moving any one field from a struct moves the whole struct).",4.2,D1,121: bar2.f1();,1,9,cannot use [X] because it was mutably borrowed,0,8,7,"On line 30, bar2 is borrowed mutably during the call to f1. f1 returns a borrow of some other ~$dq$~data~$dq$~ that is held by bar2. This means that after the call to f1, the borrow of bar2's data is still held by f4. Mutably borrowing bar2 again (by calling f1) would result in a mutable borrow and an immutable borrow being held simultaneously, which is an illegal according to rust's borrowing rules.",6
17,Sometimes,Never,Most of the time,Most of the time,How to work with heap allocation,No,Yes,C3,"99: &mut,100: out2.a.0.in_a;",0,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,7,8,"In line 24: ~$dq$~r1 = &mut out1.a[0]~$dq$~ r1 already borrow a mutable a element of out1, therefore, in line 26, the error happens due to r1 is kind of owning the reference.",4.2,D1_e,116: bar2.f1();,1,9,the parameter type [X] may not live long enough,0,5,8,"In line 30, we have borrowed a mutable reference, which line 31 again borrows a mutable reference that can live different to the one in line 30",5.8
18,Sometimes,Never,Most of the time,Always,proc_macro::Span when writing procedural macro. E0207 when implementing traits.,No,No,C2,"117: out1.a[1],",1,3,"cannot move out of  [X], a non-copy [X]",1,3,1,"test takes first argument by value, so out1.a[1] should be moved. But without first moving the whole array and disassembling it, one cannot move a single entry out of the array unless it is ~$dq$~Copy~$dq$~. Because the compiler cannot argue that all the move of elements within an array is disjoint.",10,D1,121: bar2.f1();,1,10,the parameter type [X] may not live long enough,0,10,2,"The lifetime annotation in f1 expands the lifetime of the input mutable reference to be the same as 'b, so the first call to f1 expands the lifetime of &mut bar2 to the end of the function, but the second call is within the scope, which violates the aliasing rule: no two mutable reference at the same time.",7.6
19,Never,Never,Always,Always,I had trouble fully understanding `Pin` and `Send` / `Sync` traits at first.,No,Yes,C1,"125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1]",1,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Borrowing an element from a collection requires borrowing the whole collection in current Rust version (I hope this will be improved one day in trivial cases like this one).~$br$~As such, the same field (`a` from `out1`) is borrowed twice including a mutable borrow (`&mut out1.a[0].in_a`). Iterators API can be used to prove to the compiler there is no ownership issue.",10,D2,"117: let,118: z,119: =,120: bar2.f1();",1,1,use of moved value: [X],1,1,10,"The compiler error here explains it very clearly I think, but to put in other words: Bar2 is not a Copy type, as such there is no implicit copy (useful for trivial types composed of only a few bytes such integers). This means that when a function takes an owned Bar2 (by the way, Bar2 contains a reference to a then borrowed Foo, but Bar2 itself can be owned nonetheless), the structure is said to be ~$dq$~moved~$dq$~ and ownership transferred. It cannot be used anymore using the previous label (bar2 variable in our main scope).~$br$~This is what allows Rust to prevent use after free bugs at compile time.",10
20,Sometimes,Never,Most of the time,Always,"Macros, in all of their several forms, are still confusing. Each form has its own issues with readability and ease of understanding.",No,Yes,C1_e,"125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1],133: &mut,134: out2.a.0.in_a,,135: &,136: out2.a.1",0.5,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,10,"The above is a compiler error because the array field in `Outer1` is borrowed immutably and mutable at the same time. Rust doesn't allow you to have a mutable borrow that overlaps with any other borrow. The compiler highlights the mutable borrow (and its later use) in blue, and the immutable borrow in red.~$br$~~$br$~The compiler error shows a shortcoming of rust's safety rules when it comes to indexing, in that it is too strict. It is perfectly safe to mutably access disjoint indices of an array. There's even a convenient method in the standard library to do so: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut~$br$~~$br$~The above error has to exist because implementations of the `Index` trait *could* choose to return the same item for different given indices, which would allow overlapping mutable references.",10,D1_e,"36: &'b,116: bar2.f1();,121: bar2.f1();",1,3,cannot use [X] because it was mutably borrowed,0,7,3,"Writing `fn f1(&'b mut self)` means that you are mutably borrowing an item, and that the mutable borrow should last for the entire lifetime of the item. As a result, you can't borrow that item ever again, mutably or immutably, because the first mutable borrow will still be active. It essentially makes the item unusable, which is almost never wanted.~$br$~~$br$~This is a very common mistake people make when trying to explicitly write out elided lifetimes, and the compiler error could use some work.",7.6
21,Most of the time,Sometimes,Most of the time,Most of the time,Some of the semantics surrounding option types,No,No,C3,25: [Inner;,0,10,Prefer not to answer,0,4,8,"We borrowed it once as mutable, so we have no guarantees that its content is still what we expect it to be, or even that it's still there. We can't borrow it again. ",5.8,D3,135: bar2);,1,10,cannot borrow [X] as mutable more than once at a time,1,2,8,We tried to transfer ownership to two different functions. This doesn't work unless we're passing references (?) in.,3
22,Sometimes,Sometimes,Most of the time,Most of the time,"traits part, the substitute of classes implementation is very new (I'm new to programming in general)",No,Yes,C2,"124: out2.a.1,",0,10,Prefer not to answer,0,7,10,"I haven't really understood the error here, but the compiler has provided enough explanation for me to go search for a solution or understand the problem properly using internet or the rust book",0,D1_e,121: bar2.f1();,1,10,Prefer not to answer,0,10,10,"This program, I knew there was something wrong in the let z declaration, but couldn't realize until this compiler message was shown.~$br$~A memory location can have n number of immutable reference but only 1 mutable reference at any given point of the program. ",5.8
23,Sometimes,Sometimes,Most of the time,Most of the time,Scoping,Yes,Yes,C1,128: out1.a[1],1,5,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,7,The variable ~$dq$~out1.a[_]~$dq$~ cannot be borrowed as mutable and immutable simultaneously. This is due to the ownership system in Rust. The compiler has highlighted the error-causing reference in red.,5.8,D3,135: bar2);,1,9,cannot borrow [X] as mutable more than once at a time,1,1,8,"The variable ~$dq$~bar2~$dq$~ cannot be borrowed as a mutable more than once due to the borrowing system of Rust. The compiler has highlighted the first reference of ~$dq$~bar2~$dq$~ in blue, and the second reference in red as that is the one that is causing the error.",5.8
24,Sometimes,Never,Most of the time,Most of the time,"Sometimes, error messages regarding futures can be confusing, specially when Pin/Unpin is involved.",No,Yes,C1,127: &,1,5,cannot borrow [X] as immutable because it is also borrowed as mutable,1,5,10,"When borrowing values from a array, the array itself is actually borrowed, because the compiler has no way to check that one won't borrow the same index twice. Tuples on the other hand, can have values borrowed individually.",8.4,D1,47: self.x,0,6,cannot use [X] because it was mutably borrowed,0,3,10,There can only be at most one mutable reference to a given value at the same time. The rule is violated by attempting to call a function that borrows as mutable twice.,5.8
25,Sometimes,Never,Most of the time,Always,"HRTB, proc macros",No,Yes,C1_e,"125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1]",1,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"first &mut (unique) reference passed to test is derived from out1.a through indexing (indexing turns &'a mut T into &'a mut <T as core::ops::Index<_>>::Output i.e. lifetimes are the same) 'blocking' it (out1.a) until last usage (test call). then later another indexing can't succeed because it again needs to borrow out1.a violating the uniqueness of the first reference.~$br$~~$br$~with out2 there isn't such error since the compiler can figure out that different fields (.0, .1) are borrowed (tuple fields don't use indexing)",10,D3,108: bar.x,0,3,cannot move out of [X] which is behind a mutable reference,0,2,9,"bar2 value has type Bar<'0> where '0 is anonymous lifetime equal to the whole life of bar2.  f3 takes &'a mut Bar2<'a> which means that the lifetime of the reference and the lifetime of the referent object are the same. when f3 first called, 'a = '0, which means that f3 exclusively borrows bar2 for the whole lifetime of the variable. the second `&mut bar2` is violating the uniqueness of the first &mut (unique) reference.",10
26,Sometimes,Never,Most of the time,Most of the time,Async!,No,No,C1,"125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1],133: &mut,134: out2.a.0.in_a,,135: &,136: out2.a.1",0.5,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Rust borrowing rules state that you may have EITHER:~$br$~1. A unique mutable borrow~$br$~2. Any number of immutable borrows~$br$~for a given value.~$br$~~$br$~The pattern in lines 32 and 33 of using `&mut foo` and `&foo` simultaneously, then, clearly break those rules as we are obtaining a mutable borrow to an inner element of out1/2 _and_ an immutable borrow to the containing struct.",5.8,D2,"115: bar2.f1();,120: bar2.f1();",1,10,use of moved value: [X],1,1,10,"Bar2::f1 takes self by value, so when we call it we move self, therefore repeated calls of Bar2::f1 will always be invalid, since the struct is moved out of the calling scope.~$br$~~$br$~I think the example is hard to diagnose because of all the rest of the things going on in the code. I spent a long time looking at f2 making sure it was correct. ~$br$~",8.4
27,Sometimes,Never,Most of the time,Most of the time,None,No,Yes,C3,105: &out1.a[1];,1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,9,"While the members of struct 'Outer 2's member 'a' can be partially and therefore independently borrowed by 'r3' and 'r4' because they are struct fields (tuples are anonymous structs), the same doesn't apply to  'r1' and 'r2' because referencing is made by indexing which internally calls a function taking a mutable or immutable reference to the whole member 'a'. So 'r4' takes an immutable reference to 'Outer1.a' as a whole while being mutably referenced by 'r3' in the same context which contradicts the fundamental rule of at least one mutable reference in the same context of Rust.",10,D2,120: bar2.f1();,1,9,use of moved value: [X],1,7,6,As the compiler indicates in its last message the second call of function 'f1' on 'bar2' violates against Rust's ownership system because 'f1' consume itself. Therefore variable 'bar2' gets invalidated because it doesn't implement the 'Copy' trait. Implementing 'Copy' on Bar2 would be sufficient to make this example run.,10
28,Never,Never,Most of the time,Most of the time,nothing,No,Yes,C2,119: mut,0,3,cannot borrow [X] as immutable because it is also borrowed as mutable,0,2,9,"Two `Inner` are stored in the same array, and the compiler cannot prove at compile time that they will not overlap.",4.8,D2,120: bar2.f1();,1,1,use of moved value: [X],1,1,10,bar2 has been consumed at 30L.,6
29,Most of the time,Sometimes,Sometimes,Most of the time,Syntax for working with generics and traits; interior mutability; concurrency,No,No,C1,"126: out1.a[0].in_a,",1,10,"cannot move out of  [X], a non-copy [X]",0,4,8,Accessing the underlying array in the Outer1 struct requires ownership of the entire array; which means that we can't access it both mutably and immutably in our first test.,4.8,D1_e,73: s[..ind],0,10,cannot move out of [X] because it is borrowed,0,5,4,"On line 28, bar2 is mutably borrowed by f2. We can't borrow this again mutably on line 30 because of the ownership rules. Maybe?",5.8
30,Never,Never,Always,Always,"Before the 2018 edition, the way imports were styled â€” the module system was not easy to reason with.",No,Yes,C1,136: out2.a.1,0,5,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,8,"The first parameter borrows from the *array* mutably, then borrows from the same array (albeit a different element) immutably. The lifetimes of these borrows overlap, causing the compiler the reject the error. This is not the case for the tuple as elements are borrowed individually, not from the whole object (as is the case with arrays).",10,D1,121: bar2.f1();,1,3,cannot borrow [X] as mutable more than once at a time,1,2,10,"When `bar2.f1()` is called the first time, the result is that `bar2.x` is borrowed mutably. This borrow is not dropped until the end of the scope, which overlaps with the `let z = bar2.f1();` statement, which does the same. As an object can only be mutably borrowed once at any given point, this results in an error.",5.8
31,Always,Always,Always,Always,Asynchronous programming,No,Yes,C2,"117: out1.a[1],",1,7,"cannot move out of  [X], a non-copy [X]",1,6,8,Can not remove an element from an array arbitrarily.,4.8,D2,120: bar2.f1();,1,10,use of moved value: [X],1,6,7,N/A,0
32,Sometimes,Sometimes,Most of the time,Sometimes,Pattern matching~$br$~Guaranteed memory safety,No,No,C3,"112: *r1,116: *r3",0.5,4,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,5,cannot borrow `out1.a[..]` as immutable because `out1.a[..].in_a` is also borrowed as mutable,5.8,D3,"17: Bar2<'b>,108: bar.x",0,5,"closure may outlive the current function, but it borrows [X], which is owned by the current function",0,7,6,unit-like struct definition should be written as `struct Foo,3
33,Sometimes,Never,Most of the time,Always,async/await,No,Yes,C1_e,"128: out1.a[1],136: out2.a.1",0.5,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,10,"The call accesses the array as mutable in the first argument and immutable in the second.  You are allowed many immutable reference to something, but only one reference if the reference is mutable.  As the error message says, an array can only be borrowed as a whole.~$br$~~$br$~I believe the compiler error is due to a limitation of the current borrow checker, since the arguments are different elements of the array.  I think this code will compile with Polonius, the next version of the borrow checker.  Also, note that the first argument is Copy, which is why it can be dereferenced in the function.",10,D3,131: z,0,10,lifetime of reference outlives lifetime of borrowed content,0,7,5,"I find the error confusing because the first call does not save the result, so I expect the scope of the mutable borrow would end before the next call.  I would not be surprised by the error if the first call assigned the return to a local variable, even _.~$br$~~$br$~Before NLL, the mutable borrow would not have ended until the end of scope. In that case, the error makes sense.  With NLL, it goes out scope on the last use, which is before the second call.~$br$~~$br$~My answer was related to putting a reference in a struct, something I have avoided in all but the simplest cases.",4.2
34,Sometimes,Sometimes,Most of the time,Most of the time,When return type is Future<...> it's very confusing to understand generated error,No,Yes,C2,"117: out1.a[1],",1,8,"cannot move out of  [X], a non-copy [X]",1,5,8,"Can't move variable out of immutable array. Also, struct doesn't implement Copy trait",6,D1_e,"55: (&self,",0,7,Prefer not to answer,0,3,8,"Previous line has borrowed bar2 mutably, so we can't do that again",5.8
35,Sometimes,Sometimes,Most of the time,Most of the time,"Complicated streams and iterators can be difficult to work with; https://github.com/jyn514/docs.rs/blob/29f1257e3584fe0c57fbf203f5a78c7419a648f8/src/docbuilder/rustwide_builder.rs#L226 probably doesn't *need* to use `collect()` to get rid of the `Result` in the iterator elements, but it makes the code a lot easier.~$br$~~$br$~I find async APIs difficult to write (mostly for the same reasons as above), and the error messages are frequently difficult to understand. I have trouble finding the methods I need; often this is because they come from an extension trait that isn't directly mentioned in the documentation.",No,Yes,C1_e,"125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1]",1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,8,"Rust lifetimes rules mean that values can be shared XOR mutable - because `out1.a` is borrowed mutably, it cannot be borrowed immutably. The reason it works for `out2` but not `out1` is because `out2` uses tuple fields instead of an array, so the compiler notices that the borrows are disjoint; it's not as smart for arrays. It helpfully says this in the `note`.~$br$~~$br$~A possible workaround is to use out2 instead of out1, or to move out of out1 so the compiler realizes the fields are disjoint:~$br$~`let (mut in_a, in_b) = (out1.a[0], out1.a[1]);`~$br$~(I don't recall off the top of my head if this works with indexing directly, but if not you could use a match expression.)",10,D2,120: bar2.f1();,1,2,use of moved value: [X],1,1,8,"`f2()` takes `bar2` by value. Since `bar2` does not implement Copy, it is moved into `f2` and so calling `bar2` a second time would be a use-after-free (although in this case `impl Drop for Bar2` is trivial, so it doesn't really matter). The easiest fix is to add `#[derive(Copy)]` to Bar2.",10
36,Sometimes,Sometimes,Sometimes,Most of the time,"dyn, complex trait bounds",Yes,Yes,C3,"102: let,103: r2,104: =,105: &out1.a[1];",1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,2,"Cannot borrow because when you borrow a single element from a vector, Rust borrows the entire vector. In the case of mutable borrow, the entire vector is mutably borrowed and further borrows may not occur.",10,D2,"106: ~$dq$~An,107: online,108: article~$dq$~,",0,8,lifetime of reference outlives lifetime of borrowed content,0,1,1,"f1() takes self, which consumes (moves) the ownership of bar2. fn1() would usually be responsible to re-return `self` so function chaining or reassigning bar2 variable with it would work",8.4
37,Sometimes,Sometimes,Most of the time,Most of the time,"Macros, modules, unsafe, traits",No,Yes,C2,120: out1.a[0].in_a,0,4,use of moved value: [X],0,4,10,"Since Inner is not Copy, moving will invalidate out1.a[1], but all entries of an array must be always valid.",10,D3,108: bar.x,0,10,cannot move out of [X] because it is borrowed,0,4,10,"The lifetime 'a in f3 means that the lifetime of the mutable borrow parameter bar of f3 lives as long as the reference bar.x, and since f3 is called twice while the reference bar2.x is valid, we have overlapping mutable borrows.",7.6
38,Most of the time,Sometimes,Sometimes,Most of the time,"I'm confused when it comes to container types in std::cell like Cell, RefCell, etc.",No,No,C1_e,"127: &,128: out1.a[1]",1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,9,"When calling test(), the scope created contains a mutable borrow of a struct field of an element of the array as well as an immutable borrow of another element of the same array. When the mutable borrow occurs on the array element struct field, the entire array is effectively borrowed mutably. Therefore, the 2nd immutable borrow even of a different element is prohibited by the borrow checker.",10,D3,108: bar.x,0,9,cannot move out of [X] which is behind a mutable reference,0,2,10,I got this one wrong as I believed that not capturing the return value of the first f3 call meant that the mutable borrow was no longer held at the point of the 2nd invocation. However in retrospect I now believe it is due to the lifetime annotations. The mutable borrow is explicitly taken in lifetime 'a via f3 and then in the same lifetime again at the 2nd invocation. However I'm not sure; I would rely on the compiler to help me in this case.,7.6
39,Sometimes,Sometimes,Most of the time,Most of the time,"- I don't ever need to use unsafe, but I struggle to understand all the rules of when unsafe code is Undefined Behavior.~$br$~- Related to lifetime/ownership, but specifically the interaction between generics, traits and async always leads to trouble for me",No,Yes,C3,"105: &out1.a[1];,110: &out2.a.1;",0.5,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,9,"line 24 causes r1 to take a mutable/exclusive borrow of out1 until line 28. While r1 has a mutable/exclusive borrow of out1, out1 can't be used by anything else. In this case, r2 is trying to take an immutable/shared borrow from out1 while r1 is still alive. ",5.8,D2,120: bar2.f1();,1,2,use of moved value: [X],1,1,10,A trait method with definition fn(self) will consume the object that the trait is implemented for. It does so because any function with an argument that is neither Copy nor a reference will consume will consume that argument (and make it unusable without having the method return it). Effectively the function takes ownership of that argument and so it must be specifically returned (and bound) in order to be able to use it again in the calling scope.,10
40,Most of the time,Most of the time,Sometimes,Sometimes,I am confused about some of the rules with mutable variables I get this error a lot when I'm trying to write functions...,Yes,No,C2,"117: out1.a[1],,120: out1.a[0].in_a,124: out2.a.1,,127: out2.a.0.in_a",0.3333333333,7,"cannot move out of  [X], a non-copy [X]",1,8,5,"Because the array has an inner trait, values from it cannot be copied over? ",3,D2,120: bar2.f1();,1,4,cannot use [X] because it was mutably borrowed,0,6,7,bar2 is moved by the f1() function which means it cannot be referenced again in this manner I think,8.4
41,Sometimes,Never,Most of the time,Most of the time,---,No,Yes,C3,105: &out1.a[1];,1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,7,- line 24 mutably borrows field a of instance out1 as a whole (index based accesses are trait implemented -> function call)~$br$~- line 26 immutably borrows field a of instance out1 as a whole which contradicts Rust's at most one mutable reference per scope rule (line 24 mutable borrow didn't fgo out of scope because of use in line 28),10,D2,120: bar2.f1();,1,6,use of moved value: [X],1,8,8,- calling method f1 on bar2 consumes the struct instance~$br$~- calling f1 a second time on bar2 uses a moved instance (moved out of scope)~$br$~- results in an ownership violation~$br$~- if Bar2 implemented trait Copy a second instance would be instantiated and consumed,10
42,Sometimes,Sometimes,Most of the time,Most of the time,Sync+Send traits,Yes,No,C3,"116: *r3,117: +=,118: 1;",0,7,cannot assign to [X] because it is borrowed,0,3,9,"The entire array of out1 is borrowed by the assignment to r1, not merely the element specified.  It is impermissible to then borrow it immutably while there are still references to the borrowed element.",8.4,D3,"126: f3(,127: &mut,128: bar2);",1,8,cannot borrow [X] as mutable more than once at a time,1,2,9,"Because of the lifetime specification of f3 requiring that the output has the same lifetime as the input, the output is still being held by the first call to f3.",4.8
43,Sometimes,Never,Most of the time,Always,"type system.~$br$~In languages like C, we almost only working with int, float, double, or their pointer, when dealing with an array, we manage all the pointer and index with no bounds check by default.~$br$~~$br$~In Rust, things are more differently: Rust enable bound checking by default, if we still using pointer or index, we are probably under a performance penalty. A beautiful solution maybe using some abstraction, (e.g., iter, or struct which implies Iterator trait)~$br$~send std::iter::Iter into a function may not too complex, but if we want to send something like:~$br$~let a=vec![1_i32,2,3,4,5];~$br$~let _=fun(&mut a.iter().filter(|&x|x!=4).map(|x|x*2+1) );~$br$~it is not easy to define the `fun` we want to use.~$br$~the best solution might be using generics, but things become a little bit tricky here:~$br$~`fn fun<T:Iterator<Item=i32>>( iter:&mut T )->i32{...}`~$br$~when we accidentally wrote a `fun(&mut iter)` inside the `fn fun`(just what we did in the statement `let _=fun(&mut a.iter().filter(|&x|x!=4).map(|x|x*2+1) );`), the compiler would generate an error with almost no help.",No,Yes,C1_e,"126: out1.a[0].in_a,,128: out1.a[1]",1,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"currently rust cannot borrow two different item from the same array, since the index may be the same.~$br$~~$br$~the code is `test(&mut out1.a[0].in_a, &out1.a[1]);`~$br$~if we wrote `test(&mut out1.a[1].in_a, &out1.a[1]);`, the problem is definitely ~$dq$~cannot borrow `out1.a[_]` as immutable because it is also borrowed as mutable~$dq$~.~$br$~~$br$~now compiler could not identify whether we index two different parts in a array, several versions before, compiler could not identify whether we are using different parts in a same struct, but such problem was fixed.",10,D3,108: bar.x,0,1,cannot use [X] because it was mutably borrowed,0,3,5,"12      fn f4() {~$br$~13          let foo = Foo {};~$br$~14          let mut bar2 = Bar2 { x: &foo, i: 1 };~$br$~               /*omit*/~$br$~20          let f3: for<'a> fn(&'a mut Bar2<'a>) -> &'a Foo = /*omit*/~$br$~25          let excerpt = f2(&bar2, ~$dq$~An online article~$dq$~, 2);~$br$~26          println!(~$dq$~{}~$dq$~, excerpt);~$br$~27          f3(&mut bar2);//this should be, f3(&'a mut bar2), we borrow bar2 as long as bar2 is alive, thus we could not borrow bar2 anymore.~$br$~28          let z = f3(&mut bar2);~$br$~29      }~$br$~30  }",8.4
44,Sometimes,Sometimes,Most of the time,Always,"Including modules in crates, referencing a crate's lib modules from bin or test modules~$br$~Package management, especially selecting features of dependencies",No,Yes,C2,"117: out1.a[1],",1,5,"cannot move out of  [X], a non-copy [X]",1,4,9,"test() takes ownership of the Inner it is passed, so it must be moved out of out1.a[1]. Whereas tuples and structs support partial moves (where one field is moved out and the others are dropped later), arrays do not. Since the out1.a array outlives the call to test(), it must still own all its elements. Therefore, it is possible to copy out1.a[1] into test() but not to move it.",10,D1,36: &'b,1,8,cannot borrow [X] as mutable more than once at a time,1,4,6,"f1() requires an excessively long lifetime for its argument: the Bar2 must be borrowed for the same lifetime as the Foo, even though it only needs to be borrowed for the duration of the call to f1(). Each time bar2.f1() is called, it takes a mutable borrow of bar2 that lasts for the lifetime of the variable foo, so these two mutable borrows overlap. This violates Rust's rule that mutable borrows must be exclusive.",10
45,Most of the time,Sometimes,Sometimes,Most of the time,"Getting trait bound errors because some crate or module isn't in scope. When trying to write code from scratch using a crate without examples, it's often times unclear if what I'm trying to do is possible and I'm just missing a `use` statement, or if it's not possible. ~$br$~~$br$~The type inference can sometimes be confusing, because seemingly unrelated changes can cause other code to break. I rely heavily on my IDE to indicate to me what the type being inferred is. I tried to get in the habit of explicitly typing variables, but often times the type is a generic that requires a bunch of other imports.~$br$~~$br$~Async support feels like alpha-quality right now. There is not one single runtime/executor, and often times I have to make an effort to use crates which don't have conflicting runtimes. There is not built-in support for async traits, and no built-in support for async test functions. My current approach is to do everything I can to avoid async functions, since it's much easier to make a sync function async than make an async function sync.~$br$~~$br$~While macros are very powerful and can help avoid boilerplate code, they can hide a lot of inner-workings that make them difficult to reason about. `cargo expand` can show me the expanded code, but I would rather have support within an IDE to see what a section expands to. In addition, documentation often just has examples that use the macro (such as #[tokio::main]) and don't show you how to implement the same functionality without the macro.",No,Yes,C1_e,"126: out1.a[0].in_a,,127: &,128: out1.a[1]",1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,6,8,"Rust allows either any number of references to an immutable value, or a single mutable reference. Since both parameters to `test` refer to the same variable, and you cannot borrow a single field as mutable and another as immutable, we get this above error.",5.8,D2,115: bar2.f1();,1,8,lifetime of reference outlives lifetime of borrowed content,0,3,8,Parameters that aren't references or don't implement copy are moved into the function scope. Usually you would use `fn bar(&self)` to prevent the move. The `self` parameter is ~$dq$~consumed~$dq$~ in that its ownership is passed to `f1` and thus dropped at the end of the function.,10
46,Most of the time,Sometimes,Most of the time,Always,None,No,No,C1,125: &mut,1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,7,8,First call of function >test< contradicts Rust's ownership rules because it takes an immutable and mutable referene to the same object.,5.8,D2,120: bar2.f1();,1,4,use of moved value: [X],1,6,4,Second call of method 'f1' contradicts rust's ownership rule system because first call takes 'self'.,8.4
47,Most of the time,Most of the time,Sometimes,Never,Most features/rule confuse me.,Yes,Yes,C3,100: out2.a.0.in_a;,0,10,Prefer not to answer,0,9,3,immutable error occurs,3,D2,120: bar2.f1();,1,8,cannot use [X] because it was mutably borrowed,0,7,3,~$dq$~bar2~$dq$~ cannot be borrowed as a mutable more then once at a time.,3
48,Sometimes,Sometimes,Sometimes,Most of the time,* Higher-rank trait bounds~$br$~* Pinning,No,Yes,C1,128: out1.a[1],1,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,5,8,It is impossible to simultaneously have a mutable and immutable reference to `out1.a` since code given an immutable reference should be able to assume the data will be unchanged while the reference is held.,7.6,D1,121: bar2.f1();,1,7,cannot use [X] because it was mutably borrowed,0,3,6,"`bar2` is mutably borrowed by the `bar2.f1()`, and remains borrowed since the function returns a reference with the same lifetime. Like the previous example, code with a reference should be able to assume the referenced data is not mutated, and if there is another mutable reference, that cannot be assumed. ",7.6
49,Never,Never,Most of the time,Most of the time,Generic Associated Types and other type-level features.,No,Yes,C3,105: &out1.a[1];,1,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,8,"The slice out1.a is already borrowed mutably (i.e. it can be mutated by reference). Since only a single borrow can occur when it is mutable to avoid data races and concurrent modifications, it is forbidden to borrow it immutably. While this particular program is valid, the Rust compiler treats slices as a standalone type and as such does not understand that no data races can exist between out1.a[0] and out1.a[1].",10,D2,120: bar2.f1();,1,3,use of moved value: [X],1,1,8,"The f2 function on the Bar struct takes ownership of the bar value. The second call to f2 thus would use a dropped value, which is undefined behaviour and breaks memory safety rules.",8.4
50,Sometimes,Never,Most of the time,Most of the time,Modules and macros.,No,Yes,C1_e,"44: (num:,45: &mut,46: u8,,47: inner:,48: &Inner),125: &mut,126: out1.a[0].in_a,,127: &,128: out1.a[1],133: &mut,134: out2.a.0.in_a,,135: &,136: out2.a.1",0.5,10,two closures require unique access to [X] at the same time,0,8,10,This program violates rust's borrow checker rules because the entire array of a is borrowed as a whole even though the code is only using parts of the array. This means that the array is being borrowed both immutably and mutably which is unsafe.,10,D1_e,"54: <'a>,56: s:,57: &'a,58: str,,62: &'a,63: str,107: ~$dq$~An,108: online,109: article~$dq$~,,114: excerpt);",0,10,the parameter type [X] may not live long enough,0,9,9,"The first call of f1 takes a mutable reference to bar2 with lifetime b. On the next line, a second mutable reference is made to the same bar2. This is unsafe because the data at the address of the bar2 could have changed or have been removed which would make the action unsafe.",7.6
51,Sometimes,Sometimes,Sometimes,Most of the time,I find the macros by example syntax confusing.,No,Yes,C3,105: &out1.a[1];,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,10,"On line 24, I create a mutable reference to the array out1.a. On line 26, I attempt to create an immutable reference to the same array. Rust prevents me from having both a mutable and an immutable reference to the same array.",7.6,D2,120: bar2.f1();,1,5,use of moved value: [X],1,2,10,"The first call to method f1 on line 30 ~$dq$~moves~$dq$~ or ~$dq$~consumes~$dq$~ the bar2 object. bar2 may no longer be used after line 30. However, the program attempts to reuse bar2 on line 31.",8.4
52,Most of the time,Sometimes,Sometimes,Most of the time,"Closures, Channels, Arcs",Yes,No,C1_e,"126: out1.a[0].in_a,",1,9,Prefer not to answer,0,7,5,"Not actually sure what the error is. I understand that the part underlined in red arrows is doing an immutable borrow, but I'm not sure how the function `test` is doing a mutable borrow on the `Inner` struct as there is no `mut` keyword next to it like the `num` param.~$br$~~$br$~In short: I lack the understanding of how that function is doing a mutable borrow on `inner`",4.2,D1_e,73: s[..ind],0,9,Prefer not to answer,0,2,9,"The method `f1` mutates `self`, calling it multiple times leads to multiple mutable borrows of the same variable or instance of memory the variable uses. ~$br$~~$br$~My understanding is that this is not allowed by Rust as to prevent the user of the language from making unsafe changes to the same underlying piece of memory unintentionally.~$br$~~$br$~Rust highlights the code to give the user a clear example of the unsafe practice.~$br$~~$br$~",5.8
53,Sometimes,Most of the time,Most of the time,Most of the time,traits especially advanced traits~$br$~,No,No,C3,"112: *r1,113: +=,114: 1;,116: *r3,117: +=,118: 1;",0.25,8,cannot assign to [X] because it is borrowed,0,9,2,"out1.a[1] may be changed by out1.a[0], so this is not allowed",4.8,D1,"118: let,119: z,120: =,121: bar2.f1();",1,10,wrong number of type arguments,0,10,9,A mutable variable cannot be borrowed twice.,4.2
54,Sometimes,Sometimes,Most of the time,Most of the time,Traits.,Yes,No,C3,43: main(),0,5,cannot assign to [X] because it is borrowed,0,7,7,Accessing elements outside the array.,3,D2,128: main(),0,8,"closure may outlive the current function, but it borrows [X], which is owned by the current function",0,8,8,The function returns a value that does not match any pattern.,3
55,Sometimes,Sometimes,Most of the time,Always,"Trait objects, The unsafe rust magic where the safety rules don't apply, ",No,Yes,C2,"44: inner:,45: Inner,,117: out1.a[1],,124: out2.a.1,",0.5,5,"cannot move out of  [X], a non-copy [X]",1,4,9,"out1 owns two Inner elements. test() takes the value of an Inner as its first argument. The error occurs because test expects the value of an Inner, and out.a[1] cannot move a value out of the array. ",6,D2,"36: self,91: let,92: bar2,94: Bar2,96: x:,97: &foo,,98: i:,99: 1",0.125,4,use of moved value: [X],1,4,9,"Rust moves values by default, and so calling f1() moved the value of bar2 out of f4() and into f1(). f1() goes out of scope and the value of bar2 is dropped. Then later on in f4(), bar2 is used again, but since it is moved, there is no guarantee of what will be present at the memory address of bar2 anymore since it was moved. Thus the compiler warns us, preventing a use after free .",8.4
56,Sometimes,Sometimes,Sometimes,Sometimes,"There aren't many issues, but there are few things that I forget here and there.",Yes,No,C1,128: out1.a[1],1,4,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,8,"out1 is used an an immutable so it can not be borrowed as a mutable. On line 32, it is trying to be used an an immutable, but a previous entry has already used out1 as a mutable.",5.8,D3,135: bar2);,1,4,cannot borrow [X] as mutable more than once at a time,1,4,8,bar2 has ready been used once in a pervious entry.,3
57,Sometimes,Sometimes,Most of the time,Sometimes,traits,No,Yes,C2,77: {in_a:,0,5,lifetime of reference outlives lifetime of borrowed content,0,6,6,I can't solve the problem yet,0,D3,17: Bar2<'b>,0,5,the parameter type [X] may not live long enough,0,6,6,Safety rules were violated,3
58,Sometimes,Never,Most of the time,Always,the build script,No,No,C3,"105: &out1.a[1];,110: &out2.a.1;",0.5,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,9,"out1.a is already borrowed to r1 as mutable, which means until r1 is dropped, r2 cannot borrow from out1.a again.",7.6,D2,120: bar2.f1();,1,2,use of moved value: [X],1,1,9,"bar2.f1() already consumed bar2 in line 30, thus line 31 try to use a moved value.",8.4
59,Never,Never,Always,Always,"Complex trait bounds can get quite hard to parse when you have multiple clauses with associated types and lifetimes. ~$br$~~$br$~For example, here's a beauty from `ndarray`:~$br$~~$br$~```rust~$br$~impl<'a, A, B, S, S2, D, E> Div<&'a ArrayBase<S2, E>> for ArrayBase<S, D> where~$br$~    A: Clone + Div<B, Output = A>,~$br$~    B: Clone,~$br$~    S: DataOwned<Elem = A> + DataMut,~$br$~    S2: Data<Elem = B>,~$br$~    D: Dimension,~$br$~    E: Dimension { ... }~$br$~```~$br$~~$br$~Luckily you don't see this too often in the wild. ~$br$~~$br$~It normally happens when someone needs to be *really* generic or they are trying to ~$dq$~thread the needle~$dq$~ with traits. I'd say this isn't a fault of the language, and more that the author wrote overly complicated/generalised code or the problem domain is just really complex. The language just gives you the power to express these complicated relationships.~$br$~~$br$~Some people have trouble wrapping their heads around higher-ranked trait bounds (`fn foo<F>(func: F) where F: for<'a> Fn(&'a u32)`), but once you explain that they've been using it all along hidden behind syntactic sugar (the version with lifetime elision would be ` F: Fn(&u32)`) they usually pick it up. You can also get a good understanding by just reading it out loud in english (~$dq$~for any lifetime `'a`, `F` is a function which takes a `&'a u32`~$dq$~).",No,Yes,C3,105: &out1.a[1];,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"When you create `r1` you index into the `out1.a` array, and indexing borrows the entire array (the signature with lifetime annotations is `fn index_mut<'this>(&'this mut self, index: usize) -> &'this Self::Item`). That means `out1` is borrowed mutably for the entire time `r1` is alive (i.e. between creation and last use).~$br$~~$br$~Later on we try to create `r2` by immutably indexing into the same array. The `r1` variable is still alive at this point (it is used a couple lines later), so we end up trying to borrow something immutably while it is already borrowed mutably.",10,D2,120: bar2.f1();,1,1,use of moved value: [X],1,1,10,"The `Bar2::f1()` method takes `self` by value, consuming it in the process.~$br$~~$br$~On line 30 we call `bar2.f1()`, and because `Bar2` isn't a `Copy` type this consumes the `bar2` variable (if `Bar2<'_>: Copy` then we'd consume a copy of `bar2` instead of the original). Then on line 31 we try to use something which has already been used and destroyed, so `rustc` says ~$dq$~no~$dq$~ to prevent a use-after-free.~$br$~~$br$~The compiler shows us the lifetime of `bar2` by highlighting where it was created and where it was consumed (lines 27 and 30, respectively), then it highlights the line where we use `bar2` after it is moved because that is the line that was actually blocked by the compiler. The `f1()` definition gets highlighted as a kind of FYI (~$dq$~here's `f1`'s signature and you can see it consumes `self`~$dq$~).",10
60,Most of the time,Sometimes,Most of the time,Most of the time,"Regarding ownership/borrowing, usually I understand the problem, but not how to solve it. The confusing part is when it is appropriate to use Box, Rc, Arc, Cow, etc, or how to rearrange the structure of my program to avoid lifetime issues. Lifetime annotation syntax takes some getting used to.~$br$~~$br$~Traits like AsRef, Into are sometimes confusing.",No,Yes,C2,"117: out1.a[1],,124: out2.a.1,",0.5,3,"cannot move out of  [X], a non-copy [X]",1,1,7,"Values can only have one ~$dq$~owner~$dq$~.  test() tries to take ownership, but it cannot, because the values are owned by ~$dq$~out1~$dq$~ and ~$dq$~out2~$dq$~",4.2,D2,"115: bar2.f1();,120: bar2.f1();",1,3,use of moved value: [X],1,2,8,"When a type is passed by value (rather than reference), and the type cannot be copied bitwise in a safe way (such any value containing a pointer), then Rust enforces ~$dq$~destructive move~$dq$~ semantics.~$br$~~$br$~The ownership of the value is ~$dq$~moved~$dq$~ into the new context where it has been passed.  If the ownership is not maintained by being returned and re-assigned it to some variable, then the value will be destroyed once it's ownership is abandoned.~$br$~~$br$~Bar2::f1(self) takes ownership of variable ~$dq$~bar2~$dq$~ when called, and it does not return the value. Hence, the value bound to ~$dq$~bar2~$dq$~ is destroyed once bar2.f1() is called.  When line 31 calls bar2.f1() a second time the value bound to ~$dq$~bar2~$dq$~ no longer exists, and hence this second call is invalid.",10
61,Sometimes,Never,Sometimes,Always,"TRAIT OBJECTS!  I don't know why, but I always struggle to get them working",Yes,Yes,C2,"117: out1.a[1],",1,5,"cannot move out of  [X], a non-copy [X]",1,2,10,"The ~$dq$~Copy~$dq$~ trait is impl'd in order to clone-wise copy a struct rather than creating a reference to it.  What test is doing is attempting to access out1.a[1], but because it's a value type that can't be copied due to not implementing the Copy trait, the compiler is pretty stuck at this point as the only other choice available to it is to move the value instead, which can't be done",7.6,D1,"116: bar2.f1();,121: bar2.f1();",1,6,cannot borrow [X] as mutable more than once at a time,1,2,10,"Part of Rust's safety is inherent in the fact that only one mutable reference may exist at a time.  In this particular case, it's coming into conflict due to the lifetimes being tied to one another.  When we call bar2.f2 and place the result into excerpt, that ties bar2's lifetime to excerpt, which lives for the entire scope of this function.  We then try to acquire another mutable ref, but as excerpt is still alive, z cannot have it here.",5.8
62,Always,Sometimes,Sometimes,Most of the time,Unsafe~$br$~Async,No,Yes,C2,"116: test(,117: out1.a[1],,118: &,119: mut,120: out1.a[0].in_a",1,3,cannot assign to [X] because it is borrowed,0,7,6,From my understanding the test call has both an mutable reference to a data and also wants to take the ownership of it which can't be allowed so it tries to copy the data needed but for that Copy trait needs to be implemented which is not,4.2,D3,144: {},0,10,Prefer not to answer,0,1,1,We can have only one mutable borrow at a time,5.8
63,Sometimes,Never,Most of the time,Always,No others,No,Yes,C3,109: =,0,9,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Cannot borrow variable as immutable and mutable as the same time, may cause unexpected result when access the variable in multiple threading situation.",5.8,D2,120: bar2.f1();,1,10,the parameter type [X] may not live long enough,0,1,10,The complier cannot determine whether a variable live long enough.,3
64,Sometimes,Never,Most of the time,Most of the time,I think there is none.,No,Yes,C2,"120: out1.a[0].in_a,127: out2.a.0.in_a",0,5,use of moved value: [X],0,4,7,Actually i think this should give a different error. Both parameters given to `test` fn call is owned by the same object. First parameter could move object partially and second one should give an error like ~$dq$~Cannot borrow mutably a partially moved object~$dq$~ or something better.,4.2,D3,"128: bar2);,135: bar2);",1,8,lifetime of reference outlives lifetime of borrowed content,0,9,5,I thought this shouldn't be the case with non-lexical lifetimes.,3
65,Sometimes,Sometimes,Most of the time,Most of the time,Clojures,Yes,Yes,C1_e,51: *num,0,7,Prefer not to answer,0,3,3,"The code is unsafe because an inmutable borrow occured after a mutable borrow. You can't have something borrowed for both mutable and inmutable, so safety violation.",5.8,D1_e,"54: <'a>,62: &'a",0,10,cannot use [X] because it was mutably borrowed,0,10,2,I don't understand lifetimes yet.,0
66,Sometimes,Never,Most of the time,Always,High Level: None;~$br$~Low Level: Too many to list in a meaningful way,No,Yes,C1_e,127: &,1,4,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,9,"In the error we are borrowing something like a vector as mutable, which is a (mutable in this case) pointer, length, and capacity in memory, not borrowing the individual elements as in the case of the tuple in Outer2.~$br$~~$br$~The compiler highlights the part of the struct that defines this (I think this is defined poorly and do not usually use the [Foo; n] syntax because of this.",8.4,D2,120: bar2.f1();,1,4,use of moved value: [X],1,1,10,"Without moving ownership of self there is a risk of creating a double alias to foo. This can cause problems if the memory where foo is located is accessed concurrently.~$br$~~$br$~The compiler highlights the value and each place where it is used to allow for the programmer to quickly assess where they have defined, used, and moved the value, respectively.",6
67,Most of the time,Sometimes,Most of the time,Always,mutability,Yes,No,C3,"102: let,103: r2,104: =,105: &out1.a[1];,107: let,108: r4,109: =,110: &out2.a.1;",0.4285714286,10,cannot borrow [X] as immutable because it is also borrowed as mutable,1,8,7,cannot borrow as immutable because it is also borrowed as mutable,5.8,D3,"117: ~$dq$~An,118: online,119: article~$dq$~,,120: 2);",0,10,wrong number of type arguments,0,10,7,The address has been sent twice. That's the problem.,3
68,Sometimes,Never,Always,Always,Not much I can think of.,No,Yes,C2,"117: out1.a[1],,124: out2.a.1,",0.5,1,"cannot move out of  [X], a non-copy [X]",1,1,10,The message says that the highlighted expression needs to move an instance of Inner out of a place but Inner is not copyable.,5.8,D1_e,121: bar2.f1();,1,1,cannot borrow [X] as mutable more than once at a time,1,1,10,"The first call of bar2.f1() borrows bar2 mutably with lifetime token 'b. However, a later attempt to borrow bar2 again with lifetime token 'b on bar2 is made in ~$dq$~let z = bar2.f1()~$dq$~.",7.6
69,Most of the time,Sometimes,Sometimes,Always,The current async ecosystem is confusing.,Yes,No,C2,51: *num,0,10,lifetime of reference outlives lifetime of borrowed content,0,2,10,"out1.a[1] needs to be moved into the function test in order for the function to use it, but it doesn't implement Copy.",7.6,D2,72: &,0,10,cannot move out of [X] because it is borrowed,0,4,7,"Since Bar2 doesn't implement Copy, calling the function f1 moves bar out2, which prevents it from being called again.",10
70,Never,Never,Most of the time,Most of the time,"Advanced usage of things like Pin confuse me; in general, this is related to my lack of understanding (due to lack of time spent understanding) regarding the async/await features of Rust.",No,No,C2,"117: out1.a[1],,118: &,124: out2.a.1,,125: &",0.3333333333,4,"cannot move out of  [X], a non-copy [X]",1,1,10,"We want to pass by value to test an Inner, which is a component of the larger struct Outer. The only way to do this is to allow Inner to be copied, or to allow test to take Outer as a whole.~$br$~~$br$~Even though `Inner` is built of primitive types which implement `Copy`, `Copy` is not implemented for `Inner`. It is easy to implement it using a `#[derive(Copy)]`, because the primitives are both `Copy`able.~$br$~~$br$~",5.8,D3,"126: f3(,127: &mut,128: bar2);",1,9,Prefer not to answer,0,7,4,"Rust is complaining that an item was mutably borrowed twice, in particular, bar2 is mutably borrowed on line 27, and then again on line 28. However, it is not clear to me why it is that the first borrow does not end with the function call on line 27. This likely has something to do with the ~$dq$~higher rank trait bounds~$dq$~ being used in this example.",7.6
71,Sometimes,Never,Most of the time,Always,"Things related to `Pin` and `Future` are a tad confusing, mostly the implications `Pin` has for values once they're pinned.",No,Yes,C3,105: &out1.a[1];,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,5,5,"The indexing operator applied to `out1.a` triggers a borrow of the entirety of `out1.a`, whereas using the tuple indexing for `out2.a` allows rust to understand the disjoint borrows. So attempting to borrow a field through both `out1.a[0]` and `out1.a[1]` are conflicting, notably here because one is mutable and one is immutable.~$br$~~$br$~I rated the error as more difficult than I otherwise would, due to the somewhat complex gotcha involved with the indexing operator. ",10,D1,121: bar2.f1();,1,9,cannot borrow [X] as mutable more than once at a time,1,2,6,"`Bar2::f1` borrows itself mutably for the same lifetime as its field of type `&'b Foo`. Normally the borrow caused by the function call would end immediately since the return value is unused, and trivial lexical lifetimes would have no trouble determining this. But since the lifetime is explicitly specified, vs elided, as a lifetime that lasts at least as long as `Bar2` itself can live, the borrow will never end. Which in this case, means after a first call to `Bar2::f1`, no mutable borrow of a `Bar2` can be taken again.~$br$~~$br$~The error message helps with the obvious problem of multiple mutable borrows, but doesn't explain the lifetime issue that fundamentally leads to it.",10
72,Sometimes,Sometimes,Always,Always,I am not used to the concept of working with pointers directly because I come from Java and Python. So the * is sometimes confusing.,Yes,Yes,C1_e,"128: out1.a[1],136: out2.a.1",0.5,5,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,10,"The concept of not not having shared references is violated, because a reference is passed as mutable and non mutable at the same time. ",4.2,D2,"69: self.x,",0,7,the parameter type [X] may not live long enough,0,5,9,The no shared references rule is violated because a variable is moved and used after that.,6
73,Sometimes,Never,Most of the time,Always,"sometimes the unstable features are confusing, like `#![feature(test)]`. The async stream story is confusing too",No,Yes,C3,"103: r2,108: r4",0.5,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,The code has both mutable borrow and immutable borrow in the same function for out1. So it violates the borrow check.,5.8,D2,105: bar2.f2(,0,8,lifetime of reference outlives lifetime of borrowed content,0,1,10,Didn't notice the &self was written in self. :( Never thought it is legally written in that way since the function will take ownership of the self. So it is still an ownership issue.,6
74,Sometimes,Never,Sometimes,Most of the time,partially moved struct,No,Yes,C2,"119: mut,126: mut",0,9,cannot borrow [X] as immutable because it is also borrowed as mutable,0,4,4,"cannot move a field out of a struct without copying, because otherwise that would leave the struct in a partially moved state",4.2,D3,108: bar.x,0,8,cannot move out of [X] which is behind a mutable reference,0,3,10,"bar2 is already mutably borrowed in line 27, but it's mutably borrowed again in line 28, which violates the rule that either one mutable reference or any number of immutable reference can live at a time",5.8
75,Never,Never,Most of the time,Most of the time,"Earlier Q/A phrasing may mislead.  I rarely find lifetime/ownership rules or error messages _confusing_; I understand the rules have usually have little trouble understanding the complaints about breaking them.  Much more, it's more difficult to understand how to structure my process to avoid them.~$br$~~$br$~Work with conceptually ~$dq$~nearby~$dq$~ (but not interchangeable) types, and very generic types (e.g., steps in query building with Diesel), are more common morasses.",No,Yes,C3,110: &out2.a.1;,0,9,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"Array can only be borrowed wholly, not element by element.",8.4,D3,54: for<'a>,0,10,Prefer not to answer,0,8,4,"f3() declares return to have same lifetime as input param, so (implicitly) dropped reference to return doesn't actually end the borrow.",6
76,Sometimes,Never,Most of the time,Always,Higher-Kinded Trait Bounds,No,No,C1,"127: &,136: out2.a.1",0.5,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,too tired,0,D3,"56: &Bar2,",0,6,wrong number of type arguments,0,1,10,"I don't think this error is correct for current Rust since NLL. Prior to NLL the borrow at line 27 would have lived until the end of the lexical scope; however, since NLL the borrow would end before line 28 because the returned value from f3 is not used in any way and so the borrow ends.",4.2
77,Sometimes,Sometimes,Most of the time,Most of the time,No,No,Yes,C2,"117: out1.a[1],",1,4,"cannot move out of  [X], a non-copy [X]",1,4,7,The ownership is shipped to the function while Outer1 has not been implemented with `Copy` trait.,4.2,D3,"134: &mut,135: bar2);",1,3,cannot borrow [X] as mutable more than once at a time,1,2,8,"To avoid dangling point, Rust compiler highlights the code that do mutable borrow twice",5.8
78,Sometimes,Sometimes,Most of the time,Most of the time,"Operator precedence, async function, macro",No,Yes,C3,"102: let,103: r2,104: =,105: &out1.a[1];,107: let,108: r4,109: =,110: &out2.a.1;,112: *r1,113: +=,114: 1;,116: *r3,117: +=,118: 1;",0.3636363636,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"On line 24, out1.a is mutable borrowed to r1.~$br$~On line 26, out1.a is immutable borrowed to r2.~$br$~But later on line 28, mutable reference r1 is used. So before line 26, r1 can't be dropped.~$br$~",7.6,D3,"126: f3(,127: &mut,128: bar2);",1,10,cannot borrow [X] as mutable more than once at a time,1,1,8,Bar2 is mutable borrowed twice at line 27 and 28.~$br$~,5.8
79,Sometimes,Sometimes,Most of the time,Most of the time,"Types and polymorphism, macros, shared state currency.",No,Yes,C1_e,128: out1.a[1],1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,6,4,"When a variable (out1.a) is borrowed the variable borrowing can read the value but cannot mutate (even if the original value is mutable). With immutable borrow, the borrowing variable is guaranteed that the value would not change. because out1.a is also being borrowed as a mutual it is leading to a code error. I have always found the way rust talks about their errors confusing, there is a language barrier to understanding them",5.8,D2,120: bar2.f1();,1,5,cannot use [X] because it was mutably borrowed,0,8,6,a variable (bar.2) was used after its contents have been moved somewhere else.,4.2
80,Sometimes,Sometimes,Most of the time,Most of the time,design pattern,No,Yes,C1,"125: &mut,127: &",1,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,rust only allows one mutable borrow at a time,5.8,D1_e,106: bar2.f2(,0,10,lifetime of reference outlives lifetime of borrowed content,0,6,8,understand borrow check~$br$~do not understand lifetime,3
81,Sometimes,Never,Most of the time,Always,"`async` is the big one.~$br$~Concurrency programming independent of `async`, sometimes.~$br$~Maneuvering orphan rules, sometimes.",No,Yes,C2,120: out1.a[0].in_a,0,4,"cannot move out of  [X], a non-copy [X]",1,1,9,"The indexing operation (`[1]`) is attempting to move an element out of the array, however this is not possible as the type is not `Copy` and it is not allowed to remove ownership from the array.  This is in contrast with the tuple, in which `.1` is a field, where as `[T]` has no fields per se (the compiler does not track which specific indices are referenced or moved), and indexing is implemented via a trait.  The compiler highlighted the disallowed move.",10,D3,134: &mut,1,4,cannot borrow [X] as mutable more than once at a time,1,7,5,"There are two portions of this error which require some experience in Rust.  One is that the lifetime constraints on the `f3` closure are too strict: `&'a Foo<'a>` is almost never what you want.  This forces the lifetime of the reference to match that of the struct, when you almost always want to allow it to be shorter.  The second is that if you return a reference from a function that takes `&mut`, the returned reference will maintain the exclusive borrow (even if it is not itself a `&mut`).~$br$~~$br$~These two issues combine in the example to make the exclusive borrow from the first call to `f3` last through the second call to `f3`, and hence the multible mutable borrows error.~$br$~~$br$~The compiler highlighted the second of the overlapping mutable borrows.",10
82,Always,Sometimes,Sometimes,Sometimes,Understanding what attributes are available.  Project/test organization.,No,Yes,C1_e,"134: out2.a.0.in_a,",0,9,Prefer not to answer,0,7,5,I'm really not sure.  I think you would have to use &out1.a and not &out1.a[1],4.8,D2,128: main(),0,10,Prefer not to answer,0,7,7,i can't explain it,0
83,Most of the time,Sometimes,Most of the time,Most of the time,"multiple ownership and when to use Box, Rc, Arc, Cell, Refcell",No,No,C3,105: &out1.a[1];,1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,9,The rule of only having 1 mutable reference OR many immutable references to an object at a time is violated. by taking a mutable index of out1 you borrow out1 as mutable so you cannot borrow its second element as mutable.,5.8,D1,121: bar2.f1();,1,10,cannot move out of [X] because it is borrowed,0,8,7,"This violates ownership, there are 2 mutable references. The lifetime of the result from the first call to f1() is the same as f1 so even though it is not assigned to a variable it is still considered borrowed as long as bar2 and foo are in scope so you cannot borrow again while assigning to z",7.6
84,Most of the time,Sometimes,Sometimes,Sometimes,Closure traits,Yes,Yes,C3,"105: &out1.a[1];,110: &out2.a.1;,123: r2);,127: r4);",0.5,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,4,7,"Only mutable borrow or many immutable borrows may occur at any one time. If there is a mutable borrow, memory errors would be allowed by _also_ allowing immutable borrows. Thus, mutably borrowing should disable all other borrowing while the mutable borrow is in scope.",5.8,D1_e,"47: self.x,62: &'a,106: bar2.f2(,121: bar2.f1();",0.25,10,Prefer not to answer,0,5,5,"Only one mutable borrow is allowed at a time and the lifetime parameters in `f1` indicate that `bar` and the `Foo` both have the same lifetime, which creates conflict: the mutably borrowed outer struct must not be borrowed again afterward.",10
85,Sometimes,Sometimes,Sometimes,Most of the time,General design contraints when working with a strongly typed language. My background is almost exclusively in loosely typed languages.,No,Yes,C3,94: out1.a[0].in_a;,1,6,"cannot move out of  [X], a non-copy [X]",0,3,7,"I had originally thought the error was because the first struct used a fixed array. But I see that was an incorrect belief.~$br$~This error is similar to the prior example: Rust's ownership rules have been violated by our bindings.~$br$~You can only specify 1 mutable reference or multiple immutable references.~$br$~`&mut out1.a[0].in_a` takes a mutable reference to the `in_a` property of whatever is in `a[0]`. ~$br$~~$br$~`&out1.a[1];` later takes an immutable reference to the same `a` array field, but a different index. So these two variable bindings contradict one another.~$br$~~$br$~",7.6,D3,"77: bar.x,",0,7,lifetime of reference outlives lifetime of borrowed content,0,7,9,"Two rules comprise the foundation of of Rust's ownership:~$br$~1. You may only have one, mutable reference~$br$~2. You may have multiple, immutable references~$br$~~$br$~In this case, I think multiple invocations of `f3` cause the lifetimes to overlap and violate the first rule. The second invocation of `f3` uses the same bound variable `bar2. ~$br$~~$br$~The Rust compiler highlights our offending usage because it violates the first rule of ownership I described.",7.6
86,Never,Never,Always,Always,"Match ergonomics can be confusing: for instance, `match option { Some(x) => Some(x), None => None }` may not always be simplified to `option` (that is, it may not be the identity function)",No,Yes,C2,"117: out1.a[1],",1,5,"cannot move out of  [X], a non-copy [X]",1,1,7,"The lies in partial moves: the compiler needs to understand that part of a value was moved out of some bigger instance (`Outer` in the example), so as to:~$br$~  - prevent any operations that would rely on that value being usable, such as moving the whole `Outer` struct, or calling a method on it;~$br$~  - when the compiler drops the `Outer`, it needs to know which part not to drop.~$br$~~$br$~And in this instance, it turns out that Rust can make this analysis for tuple and other product types (such as struct(ural record)s), but not for (fixed-size) arrays.~$br$~~$br$~It is not impossible that Rust would become smart enough to understand partial moves with fixed-size arrays, so that this example may compile in the future: I recommend this example be tweaked to using a more ~$dq$~complex~$dq$~ hard-to-study datatype such as a `Vec`",8.4,D3,"134: &mut,135: bar2);",1,4,cannot borrow [X] as mutable more than once at a time,1,3,4,"By having nested borrows with the same lifetime, we are expressing, at the type-level / API-wise, that we have a self-referential struct: once we witness it (_e.g._, once we construct a `&'a mut Bar<'a>`), the struct itself is considered to be borrowed until it is dropped (this is because some implementations could do that, and Rust compile-time analysis cannot be based on implementations but on type signatures). So, conservatively, the borrow checker won't let that the self-referential struct be borrowed again.~$br$~~$br$~I do agree, however, that the error message is lack-luster: ideally it would warn about the nested-borrow-with-same-lifetime code smell, since this is indeed a common error for beginners that troubles / confuses them.",6
87,Never,Never,Most of the time,Most of the time,I'm not generally confused by any of the rust language features (beyond confusion presented in the implementation thereof).,No,Yes,C2,120: out1.a[0].in_a,0,5,use of moved value: [X],0,6,5,"Moving out of an array subscript leaves the array element uninitialized, which could then be accessed with a dynamic subscript, or subsequently dropped if `Inner` had drop glue. ",8.4,D3,134: &mut,1,2,cannot borrow [X] as mutable more than once at a time,1,2,7,"Because `f3` takes `&'a mut Bar<'a>`, and `&mut T` is invariant over `T`, the lifetime of the borrow must match the lifetime of `Bar`. This means that the first borrow must still exist when `f3` is called a second time, borrowing `bar2` as mutable twice in the same lifetime (which rust does not permit). ",10
88,Most of the time,Never,Most of the time,Always,None that are unique to Rust.,No,No,C2,51: *num,0,7,cannot borrow [X] as immutable because it is also borrowed as mutable,0,3,8,The method call is trying to move ownership of the Inner property to the function independently of the Outer struct.,4.2,D3,133: f3(,0,8,"closure may outlive the current function, but it borrows [X], which is owned by the current function",0,5,7,The first mutable reference is kept alive due to the lifetime system such that when the second mutable reference is created the first one still exists.,5.8
89,Sometimes,Sometimes,Most of the time,Most of the time,Trait object restrictions,No,Yes,C3,"105: &out1.a[1];,110: &out2.a.1;",0.5,6,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,10,The immutable reference would be referencing a value that could be mutated while reading from it.,5.8,D2,120: bar2.f1();,1,3,use of moved value: [X],1,2,9,"The value had already moved, so you can't move it again (which calling f1 would do each time it is called)",8.4
90,Most of the time,Most of the time,Most of the time,Sometimes,"Rust does not contain NULL, and Option is equivalent to NULL on the ABI",Yes,No,C1,"61: fn,62: main,63: (),64: {,67: let,68: mut,69: out1,70: =,71: Outer1,72: {,75: [,76: Inner,77: {,78: in_a:,79: 1,,80: in_b:,81: 2,82: },,83: Inner,84: {,85: in_a:,86: 3,,88: 4,89: },90: ]",0,8,two closures require unique access to [X] at the same time,0,7,7,cannot return value referencing local variable,3,D1_e,"104: excerpt,106: bar2.f2(,112: println!(",0,7,lifetime of reference outlives lifetime of borrowed content,0,8,7,cannot borrow as immutable because it is also borrowed as mutable,4.2
91,Sometimes,Never,Most of the time,Always,Iterators,No,Yes,C3,"102: let,103: r2,104: =,105: &out1.a[1];,107: let,108: r4,109: =,110: &out2.a.1;",0.4285714286,5,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"The mutable reference to out1.a[0] also means there is a mutable borrow of out1, and similarly the immutable reference to out1.a[1] creates another reference to out1.~$br$~In Rust an object can have either a number of immutable references or a single mutable reference and no combination of the two and this rule is violated.",7.6,D1,72: &,0,5,lifetime of reference outlives lifetime of borrowed content,0,3,8,"In line 30 a mutable reference to bar2 is made, and it would be dropped at the end of the function.~$br$~However, a second mutable reference to bar2 is made in line 31 and that violates borrowing rules",7.6
92,Sometimes,Never,Sometimes,Sometimes,"Nothing else much, really",No,Yes,C2,"92: mut,93: out2,94: =,95: Outer2,96: {,98: a:,99: (,100: Inner,101: {in_a:,102: 1,,103: in_b:,104: 2},,105: Inner",0,7,cannot assign to [X] because it is borrowed,0,8,9,"test(out1.a[1], &mut out1.a[0].in_a) cannot be moved because the type is wrong",4.2,D2,"22: Foo,,105: bar2.f2(",0,7,cannot use [X] because it was mutably borrowed,0,7,9,The value of bar2 cannot go through because of f1(self),6
93,Sometimes,Sometimes,Most of the time,Most of the time,Pin. Higher-kinded types. Higher-rank trait bounds. Atomics.,No,Yes,C1,"125: &mut,133: &mut",0.5,2,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,10,"The safety rule which is violated is that a mutable borrow must be an exclusive borrow of an item and shared borrows must not exist at the same time. In Line 32, a mutable (exclusive) borrow of out1 is created at the same time that a shared borrow of out1 is created. ",5.8,D3,"108: bar.x,117: ~$dq$~An,118: online,119: article~$dq$~,",0,9,cannot move out of [X] which is behind a mutable reference,0,7,9,"I am surprised by this compiler error, because I expected the compiler to be able to deduce that the first mutable borrow (Line 27) is no longer active by the time the next one is created (Line 28) (~$dq$~Non-lexical lifetimes~$dq$~). I cannot explain this error based on my current level of knowledge. I suspect it has something to do with closures capturing from the surrounding scope, but I don't fully expect that it applies since they are ~$dq$~pure~$dq$~closures (that is, they reference only items from their arguments).",4.2
94,Sometimes,Sometimes,Most of the time,Most of the time,Unsafe rust,No,Yes,C1_e,"126: out1.a[0].in_a,,128: out1.a[1]",1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,9,The compiler explains that the array field in Outer1 is borrowed as a whole.~$br$~For that reason you can't have an immutable borrow to one element while also having a mutable borrow to another.,10,D1,119: z,0,10,Prefer not to answer,0,4,8,f2 takes a mutable borrow to a Bar struct. calling f2 twice creates multiple mutable borrows.,5.8
95,Sometimes,Never,Most of the time,Always,drop rules,No,Yes,C3,105: &out1.a[1];,1,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,9,When taking a references into a slice rust pessimistically (but soundly) considers the whole slice as borrowed.,8.4,D1,36: &'b,1,6,the parameter type [X] may not live long enough,0,1,9,The lifetime associated to the return value of f1 in line 30 is alive till the end of the function when rust decides to drop the value. Because this lifetime is the same than the one bar2 is borrowed with at line 31 bar2 is considered borrowed.,6
96,Sometimes,Never,Always,Always,none,No,Yes,C3,105: &out1.a[1];,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,3,9,Line 24: Mutable borrowing field out1.a (partial borrowing is not applicable -> index based = trait based access)~$br$~Line 26: Immutable borrowing field out1.a (instance out1) -> 2 mutable references in the same scope as first mutable reference needs to be in scope until line 28,10,D3,134: &mut,1,7,cannot borrow [X] as mutable more than once at a time,1,5,6,> First call of function f3 returns an immutable reference to Foo garanteed to live as long as instance bar2 ('b)~$br$~> Prevents the first mutable reference to go out of scope when f3 gets called a second time~$br$~> Rust safety rule violation: 2 mutable references in a particular scope,10
97,Sometimes,Sometimes,Always,Always,Memory safety and management,No,Yes,C3,105: &out1.a[1];,1,7,cannot borrow [X] as immutable because it is also borrowed as mutable,1,1,8,"The program can't be executed because it already borrows 'out1.a[_]' as mutable in line 24, causing an error when it tries to borrow it as immutable in line 26. The compiler has highlighted the reference in line 26 in red as that is the one causing the error.",5.8,D1,121: bar2.f1();,1,3,cannot borrow [X] as mutable more than once at a time,1,1,9,"In line 30, 'bar2' is borrowed once as mutable (due to line 27). However, in line 31 'bar2' is borrowed again as mutable, causing a borrowing error. Again, the compiler has highlighted the problematic code in red to show the line causing the error, as well as the first reference of the variable in question in blue.",5.8
98,Sometimes,Never,Most of the time,Always,Macros.  Async/await.,No,Yes,C1_e,"127: &,128: out1.a[1]",1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,9,"Even when you attempt to borrow a small part of an array, Rust borrows the entire array. On line 32 the array is first borrowed mutably, so the subsequent attempt to borrow it immutably as well violates the rule that something may only have a single mutable reference OR any number of immutable references.",10,D3,108: bar.x,0,9,cannot move out of [X] which is behind a mutable reference,0,5,9,"`bar2` is mutably borrowed by the function f3 on line 27. In the last question I assumed that line 23 was not the error, because I had missed that it is moving the x field out of bar, not creating and returning an immutable reference to the x field of bar <headpalm>. The x field can apparently be successfully moved out.  Apparently non-lexical lifetimes are not fine-grained enough for the compiler to realize that the mutable reference `&mut bar2` no longer needs to remain borrowed after line 27, so it must hold on to that borrow. Therefore in line 28 a second mutable borrow cannot occur (only one mutable reference may exist at a time).  I would have assumed that the compiler with the benefit of NLL would have allowed the mutable reference from line 27 drop after the function call and then create a new mutable reference on line 28. If the compiler had done this, I would have then expected it to emit an error about bar2 no longer being fully initialized (because of a field having been moved out and not replaced).",5.8
99,Sometimes,Sometimes,Most of the time,Most of the time,"Const generics (new in Rust 1.51), macros in general (still have not learned how to read macros, I use them but don't write my own), and the module system.",No,Yes,C3,105: &out1.a[1];,1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,5,7,"r1 is treated by the compiler as a mutable reference to an entire array, despite specifically referencing one struct field (in_a) of the the first array element (a[0]).~$br$~~$br$~That mut ref is still ~$dq$~live~$dq$~ at the time we try to take an immutable reference to the second array element when assigning r2. The ~$dq$~liveness~$dq$~ is the result of it being used later, to update r1 on line 28.~$br$~~$br$~This violates the memory safety rule where at any given time there can be multiple mutable references XOR a single mutable reference. This is important to prevent data races.~$br$~~$br$~The tricky part here is that the borrow checker is not ~$dq$~smart~$dq$~ enough to break down our borrows at the struct of field level, it treats the entire array as a ~$dq$~monolithic~$dq$~ item. This particular code is probably safe in practice.",10,D1,73: s[..ind],0,10,lifetime of reference outlives lifetime of borrowed content,0,9,3,"Despite not actually mutating bar and returning an immutable reference, f1 takes a mutable reference to self (e.g. bar), causing a mutable borrow. So can't have a 2nd mutable borrow to assign z. But this is confusing because we don't use or assign the result of the first call to f1, and even if we did it's an immutable reference.~$br$~~$br$~This violates the same memory safety rule as the previous question: multi-immutable references XOR single mutable reference at any point, to prevent data races.~$br$~~$br$~Even after seeing the warning, I don't understand why this error is occurring - it seems like the first mutable reference should no longer be ~$dq$~live~$dq$~ so the 2nd borrow should not violate safety rules. ",5.8
100,Sometimes,Most of the time,Sometimes,Sometimes,Types somtimes,Yes,No,C1_e,128: out1.a[1],1,8,cannot borrow [X] as immutable because it is also borrowed as mutable,1,9,9,Attempting to burrow part of the array as a mutable variable and then attempting to borrow another portion of the array as immutable is not allowed in Rust as the entire array must be ~$dq$~checked out~$dq$~ as one object.,10,D3,"133: f3(,135: bar2);",1,8,cannot borrow [X] as mutable more than once at a time,1,6,8,"Because the function wants to borrow the variable, it cannot be borrowed since it is out of scope and already in use. Rust does not want to have the variable mutated in different locations.",5.8
101,Never,Never,Most of the time,Always,Can't think of any that confuse me any more.,No,Yes,C3,"105: &out1.a[1];,112: *r1",1,3,cannot borrow [X] as immutable because it is also borrowed as mutable,1,2,8,"Line 24 takes a mutable borrow to a field of an element of an array. Line 26 takes an immutable borrow to a different element of the array, but Rust conservatively assumes that all array accesses could conflict, so it's marked as a potentially conflicting borrow. Mutable borrows assume only one active user of the referent at a time, so trying to take an immutable borrow violates this rule.",10,D2,"115: bar2.f1();,120: bar2.f1();",1,5,use of moved value: [X],1,1,10,"The method Bar2::f1 consumes ownership of the receiver, so bar2.f1() on line 30 moves bar2. A value cannot be used after it is moved, so trying to call bar2.f1() again on line 31 is a use-after-move.",8.4